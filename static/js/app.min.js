const {
  useState,
  useEffect
} = React;

// Utility function to format damage numbers with abbreviations
function formatDamage(number) {
  if (number < 1000) {
    return number.toString();
  } else if (number < 1000000) {
    // For numbers 1000-9999: only abbreviate if it's an exact thousand or >= 10000
    if (number >= 1000 && number < 10000) {
      // Only abbreviate exact thousands (1000, 2000, 3000, etc.)
      if (number % 1000 === 0) {
        return number / 1000 + "k";
      }
      // Show full number for non-exact thousands
      return number.toString();
    }

    // For numbers >= 10000: always abbreviate
    const value = number / 1000;
    const formatted = value.toFixed(2).replace(".", ",");
    // Remove trailing zeros after comma
    return formatted.replace(/,?0+$/, "") + "k";
  } else {
    const value = number / 1000000;
    const formatted = value.toFixed(2).replace(".", ",");
    // Remove trailing zeros after comma
    return formatted.replace(/,?0+$/, "") + "M";
  }
}
function Modal({
  isOpen,
  onClose,
  title,
  message,
  type = "info"
}) {
  if (!isOpen) return null;
  const getModalIcon = () => {
    switch (type) {
      case "error":
        return "⚠️";
      case "success":
        return "✅";
      case "warning":
        return "⚠️";
      default:
        return "ℹ️";
    }
  };
  const getModalClass = () => {
    switch (type) {
      case "error":
        return "modal-error";
      case "success":
        return "modal-success";
      case "warning":
        return "modal-warning";
      default:
        return "modal-info";
    }
  };
  return React.createElement("div", {
    className: "fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50",
    onClick: onClose
  }, React.createElement("div", {
    className: "bg-white rounded-lg min-w-80 max-w-md mx-5 shadow-2xl modal-fade-in",
    onClick: e => e.stopPropagation()
  }, React.createElement("div", {
    className: "flex items-center px-5 py-4 border-b border-gray-200 gap-3"
  }, React.createElement("span", {
    className: "text-2xl"
  }, getModalIcon()), React.createElement("h3", {
    className: "flex-1 text-lg font-semibold text-gray-900"
  }, title || "Notification"), React.createElement("button", {
    className: "bg-transparent border-none text-2xl cursor-pointer text-gray-400 p-0 w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-100 hover:text-gray-600 transition-all duration-200",
    onClick: onClose
  }, "×")), React.createElement("div", {
    className: "px-5 py-4 leading-relaxed text-gray-700"
  }, message), React.createElement("div", {
    className: "px-5 py-4 flex justify-end"
  }, React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white border-none px-5 py-2 rounded cursor-pointer text-sm font-medium transition-colors duration-200",
    onClick: onClose
  }, "OK"))));
}
function SeasonSelector({
  seasons,
  currentSeason,
  onSeasonChange,
  onCreateSeason,
  showCreateButton = false,
  currentTeam,
  showModal
}) {
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [newSeasonName, setNewSeasonName] = useState("");
  const [creating, setCreating] = useState(false);
  const handleCreateSeason = async e => {
    e.preventDefault();
    if (!newSeasonName.trim()) return;
    setCreating(true);
    try {
      const response = await fetch("/api/seasons", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: newSeasonName.trim(),
          team_id: currentTeam?.id
        })
      });
      if (response.ok) {
        const newSeason = await response.json();
        onCreateSeason(newSeason);
        setNewSeasonName("");
        setShowCreateForm(false);
      } else {
        showModal("Failed to create season", "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    } finally {
      setCreating(false);
    }
  };
  return /*#__PURE__*/React.createElement("div", {
    className: "season-selector"
  }, /*#__PURE__*/React.createElement("div", {
    className: "season-controls"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "season-select"
  }, "Season:"), /*#__PURE__*/React.createElement("select", {
    id: "season-select",
    value: currentSeason?.id || "",
    onChange: e => {
      const selectedSeason = seasons.find(s => s.id === parseInt(e.target.value));
      onSeasonChange(selectedSeason);
    }
  }, /*#__PURE__*/React.createElement("option", {
    value: ""
  }, "Select Season"), seasons.map(season => /*#__PURE__*/React.createElement("option", {
    key: season.id,
    value: season.id
  }, season.name))), showCreateButton && /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors min-h-11",
    onClick: () => setShowCreateForm(!showCreateForm)
  }, showCreateForm ? "Cancel" : "New Season")), showCreateButton && showCreateForm && /*#__PURE__*/React.createElement("form", {
    onSubmit: handleCreateSeason,
    className: "create-season-form"
  }, /*#__PURE__*/React.createElement("input", {
    type: "text",
    value: newSeasonName,
    onChange: e => setNewSeasonName(e.target.value),
    placeholder: "Enter season name",
    disabled: creating
  }), /*#__PURE__*/React.createElement("button", {
    type: "submit",
    disabled: creating || !newSeasonName.trim(),
    className: "bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors min-h-11 disabled:bg-neutral-400 disabled:cursor-not-allowed"
  }, creating ? "Creating..." : "Create")));
}
function TeamSelector({
  teams,
  currentTeam,
  onTeamChange,
  onCreateTeam,
  showCreateButton = false,
  showModal
}) {
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [newTeamName, setNewTeamName] = useState("");
  const [newTeamDescription, setNewTeamDescription] = useState("");
  const [creating, setCreating] = useState(false);
  const handleCreateTeam = async e => {
    e.preventDefault();
    if (!newTeamName.trim()) return;
    setCreating(true);
    try {
      const response = await fetch("/api/teams", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: newTeamName.trim(),
          description: newTeamDescription.trim() || null
        })
      });
      if (response.ok) {
        const newTeam = await response.json();
        onCreateTeam(newTeam);
        setNewTeamName("");
        setNewTeamDescription("");
        setShowCreateForm(false);
      } else {
        const error = await response.json();
        showModal(`Failed to create team: ${error.error}`, "Error", "error");
      }
    } catch (error) {
      console.error("Error creating team:", error);
      showModal("Error creating team", "Error", "error");
    } finally {
      setCreating(false);
    }
  };
  return /*#__PURE__*/React.createElement("div", {
    className: "team-selector"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "team-select"
  }, "Team:"), /*#__PURE__*/React.createElement("select", {
    id: "team-select",
    value: currentTeam?.id || "",
    onChange: e => {
      const selectedTeam = teams.find(team => team.id === parseInt(e.target.value));
      onTeamChange(selectedTeam);
    }
  }, /*#__PURE__*/React.createElement("option", {
    value: ""
  }, "Select a team"), teams.map(team => /*#__PURE__*/React.createElement("option", {
    key: team.id,
    value: team.id
  }, team.name))), showCreateButton && /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors min-h-11",
    onClick: () => setShowCreateForm(true)
  }, "Create Team"), showCreateForm && /*#__PURE__*/React.createElement("div", {
    className: "create-team-form"
  }, /*#__PURE__*/React.createElement("form", {
    onSubmit: handleCreateTeam
  }, /*#__PURE__*/React.createElement("input", {
    type: "text",
    placeholder: "Team name",
    value: newTeamName,
    onChange: e => setNewTeamName(e.target.value),
    required: true,
    disabled: creating
  }), /*#__PURE__*/React.createElement("input", {
    type: "text",
    placeholder: "Team description (optional)",
    value: newTeamDescription,
    onChange: e => setNewTeamDescription(e.target.value),
    disabled: creating
  }), /*#__PURE__*/React.createElement("div", {
    className: "form-actions"
  }, /*#__PURE__*/React.createElement("button", {
    type: "submit",
    disabled: creating,
    className: "bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors min-h-11 disabled:bg-neutral-400 disabled:cursor-not-allowed mr-2"
  }, creating ? "Creating..." : "Create"), /*#__PURE__*/React.createElement("button", {
    type: "button",
    onClick: () => {
      setShowCreateForm(false);
      setNewTeamName("");
      setNewTeamDescription("");
    },
    disabled: creating,
    className: "bg-neutral-500 hover:bg-neutral-600 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors min-h-11 disabled:bg-neutral-400 disabled:cursor-not-allowed"
  }, "Cancel")))));
}
function Navigation({
  currentPage,
  onPageChange,
  user
}) {
  return /*#__PURE__*/React.createElement("nav", {
    className: "flex gap-3 mb-5 border-b border-gray-300 pb-4 flex-wrap"
  }, user?.is_superadmin ?
  /*#__PURE__*/
  // Superuser only sees Super Admin panel
  React.createElement("button", {
    className: `px-5 py-2 rounded text-sm font-medium transition-colors min-h-11 ${currentPage === "super-admin" ? "bg-primary-600 text-white hover:bg-primary-700" : "bg-neutral-500 text-white hover:bg-neutral-600"}`,
    onClick: () => onPageChange("super-admin")
  }, "Super Admin") :
  /*#__PURE__*/
  // Regular users see all other panels
  React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("button", {
    className: `px-5 py-2 rounded text-sm font-medium transition-colors min-h-11 ${currentPage === "players" ? "bg-primary-600 text-white hover:bg-primary-700" : "bg-neutral-500 text-white hover:bg-neutral-600"}`,
    onClick: () => onPageChange("players")
  }, "Players"), /*#__PURE__*/React.createElement("button", {
    className: `px-5 py-2 rounded text-sm font-medium transition-colors min-h-11 ${currentPage === "battles" ? "bg-primary-600 text-white hover:bg-primary-700" : "bg-neutral-500 text-white hover:bg-neutral-600"}`,
    onClick: () => onPageChange("battles")
  }, "Battles"), /*#__PURE__*/React.createElement("button", {
    className: `px-5 py-2 rounded text-sm font-medium transition-colors min-h-11 ${currentPage === "manage" ? "bg-primary-600 text-white hover:bg-primary-700" : "bg-neutral-500 text-white hover:bg-neutral-600"}`,
    onClick: () => onPageChange("manage")
  }, "Administrator Dashboard")));
}
function ActiveRoster({
  roster,
  onRemoveFromRoster,
  onMovePlayer,
  onSwapPlayers,
  playerStats,
  seasons,
  currentSeason,
  onSeasonChange,
  onCreateSeason,
  currentTeam
}) {
  const [draggedPlayer, setDraggedPlayer] = useState(null);
  const [dragOverSlot, setDragOverSlot] = useState(null);
  const handleDragStart = (e, player) => {
    setDraggedPlayer(player);
  };
  const handleDragOver = e => {
    e.preventDefault();
  };
  const handleDragEnter = (e, position) => {
    e.preventDefault();
    setDragOverSlot(position);
  };
  const handleDragLeave = e => {
    e.preventDefault();
    setDragOverSlot(null);
  };
  const handleDrop = (e, targetPosition) => {
    e.preventDefault();
    if (draggedPlayer && draggedPlayer.roster_position !== targetPosition) {
      // Check if there's a player at the target position
      const targetPlayer = roster.find(p => p.roster_position === targetPosition);
      if (targetPlayer) {
        // Swap the two players
        onSwapPlayers(draggedPlayer.id, targetPlayer.id);
      } else {
        // Move to empty slot
        onMovePlayer(draggedPlayer.id, targetPosition);
      }
    }
    setDraggedPlayer(null);
    setDragOverSlot(null);
  };
  const rosterSlots = Array.from({
    length: 20
  }, (_, i) => {
    const position = i + 1;
    const player = roster.find(p => p.roster_position === position);
    return {
      position,
      player
    };
  });
  return /*#__PURE__*/React.createElement("div", {
    className: "active-roster"
  }, /*#__PURE__*/React.createElement("h2", null, "Active Roster (", roster.length, "/20)"), /*#__PURE__*/React.createElement(SeasonSelector, {
    seasons: seasons,
    currentSeason: currentSeason,
    onSeasonChange: onSeasonChange,
    onCreateSeason: onCreateSeason,
    currentTeam: currentTeam
  }), currentSeason ? /*#__PURE__*/React.createElement("div", {
    className: "roster-grid"
  }, rosterSlots.map(({
    position,
    player
  }) => /*#__PURE__*/React.createElement("div", {
    key: position,
    className: `roster-slot ${player ? "filled" : "empty"} ${dragOverSlot === position ? "drag-over" : ""} ${draggedPlayer && draggedPlayer.roster_position === position ? "being-dragged" : ""}`,
    onDragOver: handleDragOver,
    onDragEnter: e => handleDragEnter(e, position),
    onDragLeave: handleDragLeave,
    onDrop: e => handleDrop(e, position)
  }, /*#__PURE__*/React.createElement("div", {
    className: "slot-number"
  }, position), player ? /*#__PURE__*/React.createElement("div", {
    className: "roster-player",
    draggable: true,
    onDragStart: e => handleDragStart(e, player)
  }, /*#__PURE__*/React.createElement("div", {
    className: "player-name"
  }, player.name), playerStats[player.id] && /*#__PURE__*/React.createElement("div", {
    className: "player-battle-stats"
  }, /*#__PURE__*/React.createElement("div", {
    className: "stat"
  }, "DMG: ", formatDamage(playerStats[player.id].total_damage)), /*#__PURE__*/React.createElement("div", {
    className: "stat"
  }, "Shields:", " ", formatDamage(playerStats[player.id].total_shields_broken)), /*#__PURE__*/React.createElement("div", {
    className: "stat"
  }, "Battles: ", playerStats[player.id].battles_participated)), /*#__PURE__*/React.createElement("button", {
    className: "bg-secondary-800 hover:bg-secondary-900 text-white px-2 py-1 rounded cursor-pointer text-xs font-medium transition-colors",
    onClick: () => onRemoveFromRoster(player.id)
  }, "Remove")) : /*#__PURE__*/React.createElement("div", {
    className: "empty-slot"
  }, "Empty")))) : /*#__PURE__*/React.createElement("p", null, "Please select a season to view the active roster."));
}
function PlayerForm({
  onPlayerAdded,
  currentSeason,
  currentTeam
}) {
  const [name, setName] = useState("");
  const [gameId, setGameId] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const handleSubmit = async e => {
    e.preventDefault();
    if (!name.trim()) {
      setError("Name is required");
      return;
    }
    setLoading(true);
    setError("");
    try {
      const response = await fetch("/api/players", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: name.trim(),
          game_id: gameId.trim() || null,
          season_id: currentSeason?.id,
          team_id: currentTeam?.id
        })
      });
      if (response.ok) {
        const newPlayer = await response.json();
        onPlayerAdded(newPlayer);
        setName("");
        setGameId("");
      } else {
        const errorData = await response.json();
        setError(errorData.error || "Failed to add player");
      }
    } catch (error) {
      setError("Network error occurred");
    } finally {
      setLoading(false);
    }
  };
  return /*#__PURE__*/React.createElement("div", {
    className: "bg-secondary-100 p-5 rounded-md mb-8"
  }, /*#__PURE__*/React.createElement("h2", {
    className: "text-xl font-semibold text-gray-800 mb-4"
  }, "Add New Player"), error && /*#__PURE__*/React.createElement("div", {
    className: "error"
  }, error), /*#__PURE__*/React.createElement("form", {
    onSubmit: handleSubmit
  }, /*#__PURE__*/React.createElement("div", {
    className: "mb-4"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "name",
    className: "block mb-1 font-semibold text-gray-600"
  }, "Name *"), /*#__PURE__*/React.createElement("input", {
    type: "text",
    id: "name",
    value: name,
    onChange: e => setName(e.target.value),
    disabled: loading,
    placeholder: "Enter player name",
    className: "w-full px-3 py-2 border border-gray-300 rounded text-sm box-border md:px-3 md:py-3 md:text-base sm:px-4 sm:py-4"
  })), /*#__PURE__*/React.createElement("div", {
    className: "mb-4"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "gameId",
    className: "block mb-1 font-semibold text-gray-600"
  }, "Game ID"), /*#__PURE__*/React.createElement("input", {
    type: "text",
    id: "gameId",
    value: gameId,
    onChange: e => setGameId(e.target.value),
    disabled: loading,
    placeholder: "Enter game ID (optional)",
    maxLength: 8,
    className: "w-full px-3 py-2 border border-gray-300 rounded text-sm box-border md:px-3 md:py-3 md:text-base sm:px-4 sm:py-4"
  })), /*#__PURE__*/React.createElement("button", {
    type: "submit",
    disabled: loading,
    className: "bg-primary-600 hover:bg-primary-700 text-white px-5 py-2 rounded cursor-pointer text-sm font-medium mr-3 min-h-11 min-w-11 transition-colors md:px-4 md:py-3 md:text-base md:mr-2 sm:px-5 sm:py-4 sm:mr-1 sm:mb-1"
  }, loading ? "Adding..." : "Add Player")));
}
function PlayerList({
  players,
  onPlayerDeleted,
  onAddToRoster,
  roster,
  showModal
}) {
  const [deletingId, setDeletingId] = useState(null);
  const handleDelete = async playerId => {
    setDeletingId(playerId);
    try {
      const response = await fetch(`/api/players/${playerId}`, {
        method: "DELETE"
      });
      if (response.ok) {
        onPlayerDeleted(playerId);
      } else {
        showModal("Failed to delete player", "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    } finally {
      setDeletingId(null);
    }
  };
  const handleAddToRoster = playerId => {
    if (roster.length >= 20) {
      showModal("Roster is full (20 players maximum)", "Warning", "warning");
      return;
    }

    // Find the first empty position between 1 and 20
    const occupiedPositions = roster.map(p => p.roster_position).filter(pos => pos != null);
    let nextPosition = 1;
    for (let i = 1; i <= 20; i++) {
      if (!occupiedPositions.includes(i)) {
        nextPosition = i;
        break;
      }
    }
    onAddToRoster(playerId, nextPosition);
  };
  const isInRoster = playerId => {
    return roster.some(p => p.id === playerId);
  };

  // Filter out players that are already in the current season's roster
  const availablePlayers = players.filter(player => !isInRoster(player.id));
  return /*#__PURE__*/React.createElement("div", {
    className: "players-list"
  }, /*#__PURE__*/React.createElement("h2", null, "Available Players (", availablePlayers.length, ")"), availablePlayers.length === 0 ? /*#__PURE__*/React.createElement("p", null, "No available players. All active players are already in the roster.") : availablePlayers.map(player => /*#__PURE__*/React.createElement("div", {
    key: player.id,
    className: "player-item"
  }, /*#__PURE__*/React.createElement("div", {
    className: "player-info"
  }, /*#__PURE__*/React.createElement("div", {
    className: "player-name"
  }, player.name, player.game_id && /*#__PURE__*/React.createElement("span", {
    className: "game-id"
  }, " #", player.game_id))), /*#__PURE__*/React.createElement("div", {
    className: "player-actions"
  }, /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed",
    onClick: () => handleAddToRoster(player.id),
    disabled: roster.length >= 20
  }, "Add to Roster")))));
}
function BattleForm({
  roster,
  onBattleAdded,
  currentSeason,
  currentTeam
}) {
  const [enemyName, setEnemyName] = useState("");
  const [enemyPowerRanking, setEnemyPowerRanking] = useState("");
  const [ourScore, setOurScore] = useState("");
  const [theirScore, setTheirScore] = useState("");
  const [participantStats, setParticipantStats] = useState({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const handleParticipantChange = (playerId, field, value) => {
    setParticipantStats(prev => ({
      ...prev,
      [playerId]: {
        ...prev[playerId],
        [field]: field === "damage_done" ? Math.max(1, parseInt(value) || 1) : parseInt(value) || 0
      }
    }));
  };
  const handleSubmit = async e => {
    e.preventDefault();
    if (!enemyName.trim() || !enemyPowerRanking || !ourScore || theirScore === "") {
      setError("All battle fields are required");
      return;
    }
    setLoading(true);
    setError("");
    const participants = roster.map(player => ({
      player_id: player.id,
      damage_done: participantStats[player.id]?.damage_done || 1,
      shields_broken: participantStats[player.id]?.shields_broken || 0
    }));
    try {
      const response = await fetch("/api/battles", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          enemy_name: enemyName.trim(),
          enemy_power_ranking: parseInt(enemyPowerRanking),
          our_score: parseInt(ourScore),
          their_score: parseInt(theirScore),
          season_id: currentSeason?.id,
          team_id: currentTeam?.id,
          participants: participants
        })
      });
      if (response.ok) {
        const newBattle = await response.json();
        onBattleAdded(newBattle);
        setEnemyName("");
        setEnemyPowerRanking("");
        setOurScore("");
        setTheirScore("");
        setParticipantStats({});
      } else {
        const errorData = await response.json();
        setError(errorData.error || "Failed to create battle");
      }
    } catch (error) {
      setError("Network error occurred");
    } finally {
      setLoading(false);
    }
  };
  return /*#__PURE__*/React.createElement("div", {
    className: "form-section"
  }, /*#__PURE__*/React.createElement("h2", null, "Record New Battle"), error && /*#__PURE__*/React.createElement("div", {
    className: "error"
  }, error), /*#__PURE__*/React.createElement("form", {
    onSubmit: handleSubmit
  }, /*#__PURE__*/React.createElement("div", {
    className: "battle-info"
  }, /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "enemyName"
  }, "Enemy Name *"), /*#__PURE__*/React.createElement("input", {
    type: "text",
    id: "enemyName",
    value: enemyName,
    onChange: e => setEnemyName(e.target.value),
    disabled: loading,
    placeholder: "Enter enemy name"
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "enemyPowerRanking"
  }, "Enemy Power Ranking *"), /*#__PURE__*/React.createElement("input", {
    type: "number",
    id: "enemyPowerRanking",
    value: enemyPowerRanking,
    onChange: e => setEnemyPowerRanking(e.target.value),
    disabled: loading,
    placeholder: "Enter power ranking"
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "ourScore"
  }, "Our Score *"), /*#__PURE__*/React.createElement("input", {
    type: "number",
    id: "ourScore",
    value: ourScore,
    onChange: e => setOurScore(e.target.value),
    disabled: loading,
    placeholder: "Our score"
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "theirScore"
  }, "Their Score *"), /*#__PURE__*/React.createElement("input", {
    type: "number",
    id: "theirScore",
    value: theirScore,
    onChange: e => setTheirScore(e.target.value),
    disabled: loading,
    placeholder: "Their score"
  }))), /*#__PURE__*/React.createElement("div", {
    className: "participant-stats"
  }, /*#__PURE__*/React.createElement("h3", null, "Player Performance"), roster.length === 0 ? /*#__PURE__*/React.createElement("p", null, "No players in active roster") : /*#__PURE__*/React.createElement("div", {
    className: "stats-grid"
  }, roster.map(player => /*#__PURE__*/React.createElement("div", {
    key: player.id,
    className: "player-stats"
  }, /*#__PURE__*/React.createElement("h4", null, player.name), /*#__PURE__*/React.createElement("div", {
    className: "stat-inputs"
  }, /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", null, "Damage Done *"), /*#__PURE__*/React.createElement("input", {
    type: "number",
    min: "1",
    value: participantStats[player.id]?.damage_done || "",
    onChange: e => handleParticipantChange(player.id, "damage_done", e.target.value),
    disabled: loading,
    placeholder: "1",
    required: true
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", null, "Shields Broken"), /*#__PURE__*/React.createElement("input", {
    type: "number",
    min: "0",
    value: participantStats[player.id]?.shields_broken || 0,
    onChange: e => handleParticipantChange(player.id, "shields_broken", e.target.value),
    disabled: loading,
    placeholder: "0"
  }))))))), /*#__PURE__*/React.createElement("button", {
    type: "submit",
    disabled: loading || roster.length === 0,
    className: "bg-primary-600 hover:bg-primary-700 text-white px-5 py-2 rounded cursor-pointer text-sm font-medium transition-colors min-h-11 disabled:bg-neutral-400 disabled:cursor-not-allowed"
  }, loading ? "Recording..." : "Record Battle")));
}
function BattleEdit({
  battle,
  onBattleUpdated,
  onCancel,
  currentSeason
}) {
  const [enemyName, setEnemyName] = useState(battle.enemy_name);
  const [enemyPowerRanking, setEnemyPowerRanking] = useState(battle.enemy_power_ranking);
  const [ourScore, setOurScore] = useState(battle.our_score);
  const [theirScore, setTheirScore] = useState(battle.their_score);
  const [participants, setParticipants] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  useEffect(() => {
    // Fetch battle details with participants
    const fetchBattleDetails = async () => {
      try {
        const response = await fetch(`/api/battles/${battle.id}`);
        if (response.ok) {
          const data = await response.json();
          setParticipants(data.participants || []);
        }
      } catch (error) {
        setError("Failed to load battle details");
      }
    };
    fetchBattleDetails();
  }, [battle.id]);
  const handleParticipantChange = (participantId, field, value) => {
    setParticipants(prev => prev.map(p => p.id === participantId ? {
      ...p,
      [field]: field === "damage_done" ? Math.max(1, parseInt(value) || 1) : parseInt(value) || 0
    } : p));
  };
  const handleSubmit = async e => {
    e.preventDefault();
    setLoading(true);
    setError("");
    try {
      const response = await fetch(`/api/battles/${battle.id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          enemy_name: enemyName.trim(),
          enemy_power_ranking: parseInt(enemyPowerRanking),
          our_score: parseInt(ourScore),
          their_score: parseInt(theirScore),
          participants: participants.map(p => ({
            player_id: p.player_id,
            damage_done: p.damage_done,
            shields_broken: p.shields_broken
          }))
        })
      });
      if (response.ok) {
        const updatedBattle = await response.json();
        onBattleUpdated(updatedBattle);
        onCancel();
      } else {
        const errorData = await response.json();
        setError(errorData.error || "Failed to update battle");
      }
    } catch (error) {
      setError("Network error occurred");
    } finally {
      setLoading(false);
    }
  };
  return /*#__PURE__*/React.createElement("div", {
    className: "form-section"
  }, /*#__PURE__*/React.createElement("h3", null, "Edit Battle"), error && /*#__PURE__*/React.createElement("div", {
    className: "error"
  }, error), /*#__PURE__*/React.createElement("form", {
    onSubmit: handleSubmit
  }, /*#__PURE__*/React.createElement("div", {
    className: "battle-info"
  }, /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "enemyName"
  }, "Enemy Name *"), /*#__PURE__*/React.createElement("input", {
    type: "text",
    id: "enemyName",
    value: enemyName,
    onChange: e => setEnemyName(e.target.value),
    disabled: loading,
    required: true
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "enemyPowerRanking"
  }, "Enemy Power Ranking *"), /*#__PURE__*/React.createElement("input", {
    type: "number",
    id: "enemyPowerRanking",
    value: enemyPowerRanking,
    onChange: e => setEnemyPowerRanking(e.target.value),
    disabled: loading,
    required: true
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "ourScore"
  }, "Our Score *"), /*#__PURE__*/React.createElement("input", {
    type: "number",
    id: "ourScore",
    value: ourScore,
    onChange: e => setOurScore(e.target.value),
    disabled: loading,
    required: true
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "theirScore"
  }, "Their Score *"), /*#__PURE__*/React.createElement("input", {
    type: "number",
    id: "theirScore",
    value: theirScore,
    onChange: e => setTheirScore(e.target.value),
    disabled: loading,
    required: true
  }))), /*#__PURE__*/React.createElement("div", {
    className: "participant-stats"
  }, /*#__PURE__*/React.createElement("h4", null, "Player Performance"), participants.length === 0 ? /*#__PURE__*/React.createElement("p", null, "Loading participants...") : /*#__PURE__*/React.createElement("div", {
    className: "stats-grid"
  }, participants.map(participant => /*#__PURE__*/React.createElement("div", {
    key: participant.id,
    className: "player-stats"
  }, /*#__PURE__*/React.createElement("h5", null, participant.player_name), /*#__PURE__*/React.createElement("div", {
    className: "stat-inputs"
  }, /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", null, "Damage Done *"), /*#__PURE__*/React.createElement("input", {
    type: "number",
    min: "1",
    value: participant.damage_done,
    onChange: e => handleParticipantChange(participant.id, "damage_done", e.target.value),
    disabled: loading,
    required: true
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", null, "Shields Broken"), /*#__PURE__*/React.createElement("input", {
    type: "number",
    min: "0",
    value: participant.shields_broken,
    onChange: e => handleParticipantChange(participant.id, "shields_broken", e.target.value),
    disabled: loading
  }))))))), /*#__PURE__*/React.createElement("div", {
    style: {
      display: "flex",
      gap: "10px"
    }
  }, /*#__PURE__*/React.createElement("button", {
    type: "submit",
    disabled: loading,
    className: "bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors min-h-11 disabled:bg-neutral-400 disabled:cursor-not-allowed"
  }, loading ? "Updating..." : "Update Battle"), /*#__PURE__*/React.createElement("button", {
    type: "button",
    onClick: onCancel,
    disabled: loading,
    className: "bg-neutral-500 hover:bg-neutral-600 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors min-h-11 disabled:bg-neutral-400 disabled:cursor-not-allowed"
  }, "Cancel"))));
}
function BattleList({
  battles,
  onBattleDeleted,
  onBattleUpdated,
  currentSeason,
  showModal
}) {
  const [deletingId, setDeletingId] = useState(null);
  const [editingBattle, setEditingBattle] = useState(null);
  const handleDelete = async battleId => {
    // TODO: Convert to modal confirmation
    if (!confirm("Are you sure you want to delete this battle?")) return;
    setDeletingId(battleId);
    try {
      const response = await fetch(`/api/battles/${battleId}`, {
        method: "DELETE"
      });
      if (response.ok) {
        onBattleDeleted(battleId);
      } else {
        showModal("Failed to delete battle", "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    } finally {
      setDeletingId(null);
    }
  };
  const handleEdit = battle => {
    setEditingBattle(battle);
  };
  const handleCancelEdit = () => {
    setEditingBattle(null);
  };
  const handleBattleUpdated = updatedBattle => {
    onBattleUpdated(updatedBattle);
    setEditingBattle(null);
  };
  const formatDate = dateString => {
    return new Date(dateString).toLocaleDateString();
  };
  if (editingBattle) {
    return /*#__PURE__*/React.createElement(BattleEdit, {
      battle: editingBattle,
      onBattleUpdated: handleBattleUpdated,
      onCancel: handleCancelEdit,
      currentSeason: currentSeason
    });
  }
  return /*#__PURE__*/React.createElement("div", {
    className: "battles-list"
  }, /*#__PURE__*/React.createElement("h2", null, "Battle History (", battles.length, ")"), battles.length === 0 ? /*#__PURE__*/React.createElement("p", null, "No battles recorded yet.") : /*#__PURE__*/React.createElement("div", {
    className: "battles-table"
  }, /*#__PURE__*/React.createElement("div", {
    className: "table-header"
  }, /*#__PURE__*/React.createElement("div", null, "Date"), /*#__PURE__*/React.createElement("div", null, "Enemy"), /*#__PURE__*/React.createElement("div", null, "Power Ranking"), /*#__PURE__*/React.createElement("div", null, "Score"), /*#__PURE__*/React.createElement("div", null, "Total Damage"), /*#__PURE__*/React.createElement("div", null, "Result"), /*#__PURE__*/React.createElement("div", null, "Actions")), battles.map(battle => /*#__PURE__*/React.createElement("div", {
    key: battle.id,
    className: "table-row"
  }, /*#__PURE__*/React.createElement("div", null, formatDate(battle.date_created)), /*#__PURE__*/React.createElement("div", null, battle.enemy_name), /*#__PURE__*/React.createElement("div", null, battle.enemy_power_ranking), /*#__PURE__*/React.createElement("div", null, battle.our_score, " - ", battle.their_score), /*#__PURE__*/React.createElement("div", {
    className: "total-damage"
  }, formatDamage(battle.total_damage || 0)), /*#__PURE__*/React.createElement("div", {
    className: `battle-result ${battle.our_score > battle.their_score ? "win" : battle.our_score < battle.their_score ? "loss" : "tie"}`
  }, battle.our_score > battle.their_score ? "Win" : battle.our_score < battle.their_score ? "Loss" : "Tie"), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors",
    onClick: () => handleEdit(battle)
  }, "Edit"), /*#__PURE__*/React.createElement("button", {
    className: "bg-secondary-800 hover:bg-secondary-900 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed",
    onClick: () => handleDelete(battle.id),
    disabled: deletingId === battle.id
  }, deletingId === battle.id ? "Deleting..." : "Delete"))))));
}
function AdminDashboard({
  players,
  onPlayerStatusChanged,
  onPlayerDeleted,
  onPlayerAdded,
  seasons,
  onSeasonDeleted,
  onSeasonUpdated,
  currentSeason,
  onSeasonChange,
  onCreateSeason,
  battles,
  onBattleUpdated,
  currentTeam
}) {
  const [updatingId, setUpdatingId] = useState(null);
  const [editingGameId, setEditingGameId] = useState(null);
  const [gameIdValues, setGameIdValues] = useState({});
  const [error, setError] = useState("");
  const [deletingSeasonId, setDeletingSeasonId] = useState(null);
  const [editingSeasonId, setEditingSeasonId] = useState(null);
  const [seasonNameValues, setSeasonNameValues] = useState({});
  const [updatingSeasonId, setUpdatingSeasonId] = useState(null);
  const handleStatusChange = async (playerId, newStatus) => {
    setUpdatingId(playerId);
    setError("");
    try {
      const response = await fetch(`/api/players/${playerId}/status`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          status: newStatus
        })
      });
      if (response.ok) {
        const updatedPlayer = await response.json();
        onPlayerStatusChanged(updatedPlayer);
      } else {
        setError("Failed to update player status");
      }
    } catch (error) {
      setError("Network error occurred");
    } finally {
      setUpdatingId(null);
    }
  };
  const handleGameIdEdit = (playerId, currentGameId) => {
    setEditingGameId(playerId);
    setError("");
    setGameIdValues(prev => ({
      ...prev,
      [playerId]: currentGameId || ""
    }));
  };
  const handleGameIdSave = async playerId => {
    setUpdatingId(playerId);
    setError("");
    try {
      const response = await fetch(`/api/players/${playerId}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          game_id: gameIdValues[playerId]?.trim() || null
        })
      });
      if (response.ok) {
        const updatedPlayer = await response.json();
        onPlayerStatusChanged(updatedPlayer);
        setEditingGameId(null);
      } else {
        const errorData = await response.json();
        setError(errorData.error || "Failed to update game ID");
      }
    } catch (error) {
      setError("Network error occurred");
    } finally {
      setUpdatingId(null);
    }
  };
  const handleGameIdCancel = () => {
    setEditingGameId(null);
    setGameIdValues({});
    setError("");
  };
  const handleSeasonRename = (seasonId, currentName) => {
    setEditingSeasonId(seasonId);
    setError("");
    setSeasonNameValues(prev => ({
      ...prev,
      [seasonId]: currentName
    }));
  };
  const handleSeasonNameSave = async seasonId => {
    const newName = seasonNameValues[seasonId]?.trim();
    if (!newName) {
      setError("Season name cannot be empty");
      return;
    }
    setUpdatingSeasonId(seasonId);
    setError("");
    try {
      const response = await fetch(`/api/seasons/${seasonId}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name: newName
        })
      });
      if (response.ok) {
        const updatedSeason = await response.json();
        onSeasonUpdated(updatedSeason);
        setEditingSeasonId(null);
        setSeasonNameValues({});
      } else {
        const errorData = await response.json();
        setError(errorData.error || "Failed to update season name");
      }
    } catch (error) {
      setError("Network error occurred");
    } finally {
      setUpdatingSeasonId(null);
    }
  };
  const handleSeasonNameCancel = () => {
    setEditingSeasonId(null);
    setSeasonNameValues({});
    setError("");
  };
  const handleSeasonDelete = async seasonId => {
    if (!confirm("Are you sure you want to delete this season? This will delete all associated players and battles.")) return;
    setDeletingSeasonId(seasonId);
    setError("");
    try {
      const response = await fetch(`/api/seasons/${seasonId}`, {
        method: "DELETE"
      });
      if (response.ok) {
        onSeasonDeleted(seasonId);
      } else {
        const errorData = await response.json();
        setError(errorData.error || "Failed to delete season");
      }
    } catch (error) {
      setError("Network error occurred");
    } finally {
      setDeletingSeasonId(null);
    }
  };
  const handleDelete = async playerId => {
    if (!confirm("Are you sure you want to delete this player?")) return;
    setUpdatingId(playerId);
    setError("");
    try {
      const response = await fetch(`/api/players/${playerId}`, {
        method: "DELETE"
      });
      if (response.ok) {
        onPlayerDeleted(playerId);
      } else {
        setError("Failed to delete player");
      }
    } catch (error) {
      setError("Network error occurred");
    } finally {
      setUpdatingId(null);
    }
  };
  return /*#__PURE__*/React.createElement("div", {
    className: "admin-dashboard"
  }, /*#__PURE__*/React.createElement("h2", null, "Administrator Dashboard"), error && /*#__PURE__*/React.createElement("div", {
    className: "error"
  }, error), /*#__PURE__*/React.createElement("div", {
    className: "dashboard-sections"
  }, /*#__PURE__*/React.createElement("div", {
    className: "dashboard-row"
  }, /*#__PURE__*/React.createElement("div", {
    className: "dashboard-section"
  }, /*#__PURE__*/React.createElement("h3", null, "Add New Player"), /*#__PURE__*/React.createElement(PlayerForm, {
    onPlayerAdded: onPlayerAdded,
    currentSeason: currentSeason,
    currentTeam: currentTeam
  })), /*#__PURE__*/React.createElement("div", {
    className: "dashboard-section"
  }, /*#__PURE__*/React.createElement("h3", null, "Season Selection"), /*#__PURE__*/React.createElement(SeasonSelector, {
    seasons: seasons,
    currentSeason: currentSeason,
    onSeasonChange: onSeasonChange,
    onCreateSeason: onCreateSeason,
    showCreateButton: true,
    currentTeam: currentTeam
  }))), /*#__PURE__*/React.createElement("div", {
    className: "dashboard-section"
  }, /*#__PURE__*/React.createElement("h3", null, "Season Management"), /*#__PURE__*/React.createElement("div", {
    className: "seasons-admin"
  }, seasons.length === 0 ? /*#__PURE__*/React.createElement("p", null, "No seasons created yet.") : /*#__PURE__*/React.createElement("div", {
    className: "seasons-table"
  }, /*#__PURE__*/React.createElement("div", {
    className: "table-header"
  }, /*#__PURE__*/React.createElement("div", null, "Season Name"), /*#__PURE__*/React.createElement("div", null, "Created"), /*#__PURE__*/React.createElement("div", null, "Actions")), seasons.map(season => /*#__PURE__*/React.createElement("div", {
    key: season.id,
    className: "table-row"
  }, /*#__PURE__*/React.createElement("div", {
    className: "season-name"
  }, editingSeasonId === season.id ? /*#__PURE__*/React.createElement("div", {
    className: "season-name-edit"
  }, /*#__PURE__*/React.createElement("input", {
    type: "text",
    value: seasonNameValues[season.id] || "",
    onChange: e => setSeasonNameValues(prev => ({
      ...prev,
      [season.id]: e.target.value
    })),
    className: "season-name-input",
    placeholder: "Enter season name"
  }), /*#__PURE__*/React.createElement("div", {
    className: "season-name-actions"
  }, /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed mr-2",
    onClick: () => handleSeasonNameSave(season.id),
    disabled: updatingSeasonId === season.id
  }, updatingSeasonId === season.id ? "Saving..." : "Save"), /*#__PURE__*/React.createElement("button", {
    className: "bg-neutral-500 hover:bg-neutral-600 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed",
    onClick: handleSeasonNameCancel,
    disabled: updatingSeasonId === season.id
  }, "Cancel"))) : season.name), /*#__PURE__*/React.createElement("div", {
    className: "season-date"
  }, new Date(season.date_created).toLocaleDateString()), /*#__PURE__*/React.createElement("div", {
    className: "season-actions"
  }, editingSeasonId === season.id ? null : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors mr-2",
    onClick: () => handleSeasonRename(season.id, season.name)
  }, "Rename"), /*#__PURE__*/React.createElement("button", {
    className: "bg-secondary-800 hover:bg-secondary-900 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed",
    onClick: () => handleSeasonDelete(season.id),
    disabled: deletingSeasonId === season.id
  }, deletingSeasonId === season.id ? "Deleting..." : "Delete")))))))), /*#__PURE__*/React.createElement("div", {
    className: "dashboard-section"
  }, /*#__PURE__*/React.createElement("h3", null, "Battle Management"), /*#__PURE__*/React.createElement("div", {
    className: "battles-admin"
  }, !currentSeason ? /*#__PURE__*/React.createElement("p", null, "Please select a season to manage battles.") : battles.length === 0 ? /*#__PURE__*/React.createElement("p", null, "No battles recorded for this season.") : /*#__PURE__*/React.createElement(BattleList, {
    battles: battles,
    onBattleDeleted: () => {},
    onBattleUpdated: onBattleUpdated,
    currentSeason: currentSeason
  }))), /*#__PURE__*/React.createElement("div", {
    className: "dashboard-section"
  }, /*#__PURE__*/React.createElement("h3", null, "Player Management"), /*#__PURE__*/React.createElement("div", {
    className: "players-admin"
  }, players.length === 0 ? /*#__PURE__*/React.createElement("p", null, "No players in database.") : /*#__PURE__*/React.createElement("div", {
    className: "players-table"
  }, /*#__PURE__*/React.createElement("div", {
    className: "table-header"
  }, /*#__PURE__*/React.createElement("div", null, "Name"), /*#__PURE__*/React.createElement("div", null, "Game ID"), /*#__PURE__*/React.createElement("div", null, "Season"), /*#__PURE__*/React.createElement("div", null, "Status"), /*#__PURE__*/React.createElement("div", null, "Actions")), players.map(player => /*#__PURE__*/React.createElement("div", {
    key: player.id,
    className: "table-row"
  }, /*#__PURE__*/React.createElement("div", {
    className: "player-name"
  }, player.name), /*#__PURE__*/React.createElement("div", {
    className: "player-game-id"
  }, editingGameId === player.id ? /*#__PURE__*/React.createElement("div", {
    className: "game-id-edit"
  }, /*#__PURE__*/React.createElement("input", {
    type: "text",
    value: gameIdValues[player.id] || "",
    onChange: e => setGameIdValues(prev => ({
      ...prev,
      [player.id]: e.target.value
    })),
    disabled: updatingId === player.id,
    placeholder: "Enter game ID",
    maxLength: 8
  }), /*#__PURE__*/React.createElement("button", {
    onClick: () => handleGameIdSave(player.id),
    disabled: updatingId === player.id,
    className: "bg-primary-600 hover:bg-primary-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed mr-2"
  }, updatingId === player.id ? "Saving..." : "Save"), /*#__PURE__*/React.createElement("button", {
    onClick: handleGameIdCancel,
    disabled: updatingId === player.id,
    className: "bg-neutral-500 hover:bg-neutral-600 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed"
  }, "Cancel")) : /*#__PURE__*/React.createElement("div", {
    className: "game-id-display"
  }, /*#__PURE__*/React.createElement("span", null, player.game_id || "Not set"), /*#__PURE__*/React.createElement("button", {
    onClick: () => handleGameIdEdit(player.id, player.game_id),
    disabled: updatingId === player.id,
    className: "bg-primary-600 hover:bg-primary-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors"
  }, "Edit"))), /*#__PURE__*/React.createElement("div", {
    className: "player-season"
  }, player.seasons && player.seasons.length > 0 ? /*#__PURE__*/React.createElement("div", {
    className: "seasons-display",
    title: player.seasons.map(s => s.name).join(", ")
  }, player.seasons.length <= 2 ? player.seasons.map(s => s.name).join(", ") : `${player.seasons.slice(0, 2).map(s => s.name).join(", ")} (+${player.seasons.length - 2} more)`) : /*#__PURE__*/React.createElement("span", {
    className: "no-seasons"
  }, "No seasons")), /*#__PURE__*/React.createElement("div", {
    className: `player-status ${player.status}`
  }, player.status), /*#__PURE__*/React.createElement("div", {
    className: "player-actions"
  }, /*#__PURE__*/React.createElement("button", {
    className: `px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed mr-2 ${player.status === "active" ? "bg-secondary-700 hover:bg-secondary-800 text-white" : "bg-primary-600 hover:bg-primary-700 text-white"}`,
    onClick: () => handleStatusChange(player.id, player.status === "active" ? "inactive" : "active"),
    disabled: updatingId === player.id
  }, updatingId === player.id ? "Updating..." : player.status === "active" ? "Deactivate" : "Activate"), /*#__PURE__*/React.createElement("button", {
    className: "bg-secondary-800 hover:bg-secondary-900 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed",
    onClick: () => handleDelete(player.id),
    disabled: updatingId === player.id
  }, "Delete")))))))));
}
function SuperAdminPanel({
  showModal
}) {
  const [users, setUsers] = useState([]);
  const [teams, setTeams] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [newUser, setNewUser] = useState({
    username: "",
    password: ""
  });
  const [creating, setCreating] = useState(false);
  const [editingUser, setEditingUser] = useState(null);
  const [editForm, setEditForm] = useState({
    username: "",
    password: "",
    team_ids: []
  });
  const [updating, setUpdating] = useState(false);

  // Team management state
  const [showCreateTeamForm, setShowCreateTeamForm] = useState(false);
  const [newTeam, setNewTeam] = useState({
    name: "",
    description: ""
  });
  const [creatingTeam, setCreatingTeam] = useState(false);
  const [editingTeam, setEditingTeam] = useState(null);
  const [editTeamForm, setEditTeamForm] = useState({
    name: "",
    description: ""
  });
  const [updatingTeam, setUpdatingTeam] = useState(false);
  const fetchUsers = async () => {
    try {
      const response = await fetch("/api/users");
      if (response.ok) {
        const data = await response.json();
        setUsers(data);
      } else {
        setError("Failed to fetch users");
      }
    } catch (error) {
      setError("Network error occurred");
    }
  };
  const fetchTeams = async () => {
    try {
      const response = await fetch("/api/teams");
      if (response.ok) {
        const data = await response.json();
        setTeams(data);
      } else {
        setError("Failed to fetch teams");
      }
    } catch (error) {
      setError("Network error occurred");
    }
  };
  const fetchData = async () => {
    setLoading(true);
    await Promise.all([fetchUsers(), fetchTeams()]);
    setLoading(false);
  };
  const handleCreateUser = async e => {
    e.preventDefault();
    if (!newUser.username.trim() || !newUser.password.trim()) {
      showModal("Username and password are required", "Error", "error");
      return;
    }
    setCreating(true);
    try {
      const response = await fetch("/api/users", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(newUser)
      });
      if (response.ok) {
        const createdUser = await response.json();
        setUsers([...users, createdUser]);
        setNewUser({
          username: "",
          password: ""
        });
        setShowCreateForm(false);
        showModal("User created successfully", "Success", "success");
      } else {
        const errorData = await response.json();
        showModal(errorData.error || "Failed to create user", "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    } finally {
      setCreating(false);
    }
  };
  const handleDeleteUser = async userId => {
    if (!confirm("Are you sure you want to delete this user?")) return;
    try {
      const response = await fetch(`/api/users/${userId}`, {
        method: "DELETE"
      });
      if (response.ok) {
        setUsers(users.filter(user => user.id !== userId));
        showModal("User deleted successfully", "Success", "success");
      } else {
        showModal("Failed to delete user", "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    }
  };
  const handleEditUser = user => {
    setEditingUser(user.id);
    setEditForm({
      username: user.username,
      password: "",
      team_ids: user.teams ? user.teams.map(team => team.id) : []
    });
  };
  const handleCancelEdit = () => {
    setEditingUser(null);
    setEditForm({
      username: "",
      password: "",
      team_ids: []
    });
  };
  const handleUpdateUser = async userId => {
    if (!editForm.username.trim()) {
      showModal("Username cannot be empty", "Error", "error");
      return;
    }
    setUpdating(true);
    try {
      // Update user basic info first
      const updateData = {
        username: editForm.username.trim()
      };

      // Only include password if it's provided
      if (editForm.password.trim()) {
        updateData.password = editForm.password.trim();
      }
      const userResponse = await fetch(`/api/users/${userId}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(updateData)
      });
      if (!userResponse.ok) {
        const errorData = await userResponse.json();
        showModal(errorData.error || "Failed to update user", "Error", "error");
        return;
      }

      // Update team assignments
      const teamResponse = await fetch(`/api/users/${userId}/teams`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          team_ids: editForm.team_ids
        })
      });
      if (teamResponse.ok) {
        const updatedUser = await teamResponse.json();
        setUsers(users.map(user => user.id === userId ? updatedUser : user));
        setEditingUser(null);
        setEditForm({
          username: "",
          password: "",
          team_ids: []
        });
        showModal("User updated successfully", "Success", "success");
      } else {
        const errorData = await teamResponse.json();
        showModal(errorData.error || "Failed to update user teams", "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    } finally {
      setUpdating(false);
    }
  };

  // Team management functions
  const handleCreateTeam = async e => {
    e.preventDefault();
    if (!newTeam.name.trim()) {
      showModal("Team name is required", "Error", "error");
      return;
    }
    setCreatingTeam(true);
    try {
      const response = await fetch("/api/teams", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(newTeam)
      });
      if (response.ok) {
        const createdTeam = await response.json();
        setTeams([...teams, createdTeam]);
        setNewTeam({
          name: "",
          description: ""
        });
        setShowCreateTeamForm(false);
        showModal("Team created successfully", "Success", "success");
      } else {
        const errorData = await response.json();
        showModal(errorData.error || "Failed to create team", "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    } finally {
      setCreatingTeam(false);
    }
  };
  const handleEditTeam = team => {
    setEditingTeam(team.id);
    setEditTeamForm({
      name: team.name,
      description: team.description || ""
    });
  };
  const handleCancelTeamEdit = () => {
    setEditingTeam(null);
    setEditTeamForm({
      name: "",
      description: ""
    });
  };
  const handleUpdateTeam = async teamId => {
    if (!editTeamForm.name.trim()) {
      showModal("Team name cannot be empty", "Error", "error");
      return;
    }
    setUpdatingTeam(true);
    try {
      const updateData = {
        name: editTeamForm.name.trim(),
        description: editTeamForm.description.trim()
      };
      const response = await fetch(`/api/teams/${teamId}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(updateData)
      });
      if (response.ok) {
        const updatedTeam = await response.json();
        setTeams(teams.map(team => team.id === teamId ? updatedTeam : team));
        setEditingTeam(null);
        setEditTeamForm({
          name: "",
          description: ""
        });
        showModal("Team updated successfully", "Success", "success");
      } else {
        const errorData = await response.json();
        showModal(errorData.error || "Failed to update team", "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    } finally {
      setUpdatingTeam(false);
    }
  };
  const handleDeleteTeam = async teamId => {
    if (!confirm("Are you sure you want to delete this team?")) return;
    try {
      const response = await fetch(`/api/teams/${teamId}`, {
        method: "DELETE"
      });
      if (response.ok) {
        setTeams(teams.filter(team => team.id !== teamId));
        showModal("Team deleted successfully", "Success", "success");
      } else {
        const errorData = await response.json();
        showModal(errorData.error || "Failed to delete team", "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    }
  };
  useEffect(() => {
    fetchData();
  }, []);
  if (loading) {
    return /*#__PURE__*/React.createElement("div", {
      className: "loading"
    }, "Loading users...");
  }
  return /*#__PURE__*/React.createElement("div", {
    className: "super-admin-panel"
  }, /*#__PURE__*/React.createElement("h2", null, "Super Admin Panel"), error && /*#__PURE__*/React.createElement("div", {
    className: "error"
  }, error), /*#__PURE__*/React.createElement("div", {
    className: "user-management"
  }, /*#__PURE__*/React.createElement("div", {
    className: "section-header"
  }, /*#__PURE__*/React.createElement("h3", null, "User Management"), /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors",
    onClick: () => setShowCreateForm(!showCreateForm)
  }, showCreateForm ? "Cancel" : "Create New User")), showCreateForm && /*#__PURE__*/React.createElement("form", {
    onSubmit: handleCreateUser,
    className: "create-user-form"
  }, /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "username"
  }, "Username:"), /*#__PURE__*/React.createElement("input", {
    type: "text",
    id: "username",
    value: newUser.username,
    onChange: e => setNewUser({
      ...newUser,
      username: e.target.value
    }),
    required: true
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "password"
  }, "Password:"), /*#__PURE__*/React.createElement("input", {
    type: "password",
    id: "password",
    value: newUser.password,
    onChange: e => setNewUser({
      ...newUser,
      password: e.target.value
    }),
    required: true
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-actions"
  }, /*#__PURE__*/React.createElement("button", {
    type: "submit",
    disabled: creating,
    className: "bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed"
  }, creating ? "Creating..." : "Create User"))), /*#__PURE__*/React.createElement("div", {
    className: "users-list"
  }, /*#__PURE__*/React.createElement("h4", null, "Existing Users"), users.length === 0 ? /*#__PURE__*/React.createElement("p", null, "No users found.") : /*#__PURE__*/React.createElement("table", {
    className: "users-table"
  }, /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("th", null, "ID"), /*#__PURE__*/React.createElement("th", null, "Username"), /*#__PURE__*/React.createElement("th", null, "Team"), /*#__PURE__*/React.createElement("th", null, "Date Created / Password"), /*#__PURE__*/React.createElement("th", null, "Actions"))), /*#__PURE__*/React.createElement("tbody", null, users.map(user => /*#__PURE__*/React.createElement("tr", {
    key: user.id
  }, /*#__PURE__*/React.createElement("td", null, user.id), /*#__PURE__*/React.createElement("td", null, editingUser === user.id ? /*#__PURE__*/React.createElement("input", {
    type: "text",
    value: editForm.username,
    onChange: e => setEditForm({
      ...editForm,
      username: e.target.value
    }),
    className: "edit-input"
  }) : user.username), /*#__PURE__*/React.createElement("td", null, editingUser === user.id ? /*#__PURE__*/React.createElement("select", {
    multiple: true,
    value: editForm.team_ids.map(id => id.toString()),
    onChange: e => {
      const selectedValues = Array.from(e.target.selectedOptions, option => parseInt(option.value));
      setEditForm({
        ...editForm,
        team_ids: selectedValues
      });
    },
    className: "w-full px-3 py-2 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 min-h-20 max-h-32"
  }, teams.map(team => /*#__PURE__*/React.createElement("option", {
    key: team.id,
    value: team.id
  }, team.name))) : /*#__PURE__*/React.createElement("div", {
    className: "user-teams"
  }, user.teams && user.teams.length > 0 ? user.teams.map(team => /*#__PURE__*/React.createElement("span", {
    key: team.id,
    className: "team-badge"
  }, team.name)) : /*#__PURE__*/React.createElement("span", {
    className: "no-teams"
  }, "No Teams"))), /*#__PURE__*/React.createElement("td", null, editingUser === user.id ? /*#__PURE__*/React.createElement("div", {
    className: "password-edit"
  }, /*#__PURE__*/React.createElement("input", {
    type: "password",
    value: editForm.password,
    onChange: e => setEditForm({
      ...editForm,
      password: e.target.value
    }),
    placeholder: "New password (optional)",
    className: "edit-input"
  }), /*#__PURE__*/React.createElement("small", {
    className: "password-hint"
  }, "Leave blank to keep current password")) : new Date(user.date_created).toLocaleDateString()), /*#__PURE__*/React.createElement("td", null, editingUser === user.id ? /*#__PURE__*/React.createElement("div", {
    className: "edit-actions"
  }, /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed mr-2",
    onClick: () => handleUpdateUser(user.id),
    disabled: updating
  }, updating ? "Saving..." : "Save"), /*#__PURE__*/React.createElement("button", {
    className: "bg-neutral-500 hover:bg-neutral-600 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed",
    onClick: handleCancelEdit,
    disabled: updating
  }, "Cancel")) : /*#__PURE__*/React.createElement("div", {
    className: "user-actions"
  }, /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors mr-2",
    onClick: () => handleEditUser(user)
  }, "Edit"), /*#__PURE__*/React.createElement("button", {
    className: "bg-secondary-800 hover:bg-secondary-900 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors",
    onClick: () => handleDeleteUser(user.id)
  }, "Delete"))))))))), /*#__PURE__*/React.createElement("div", {
    className: "team-management"
  }, /*#__PURE__*/React.createElement("div", {
    className: "section-header"
  }, /*#__PURE__*/React.createElement("h3", null, "Team Management"), /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors",
    onClick: () => setShowCreateTeamForm(!showCreateTeamForm)
  }, showCreateTeamForm ? "Cancel" : "Create New Team")), showCreateTeamForm && /*#__PURE__*/React.createElement("form", {
    onSubmit: handleCreateTeam,
    className: "create-team-form"
  }, /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "team-name"
  }, "Team Name:"), /*#__PURE__*/React.createElement("input", {
    type: "text",
    id: "team-name",
    value: newTeam.name,
    onChange: e => setNewTeam({
      ...newTeam,
      name: e.target.value
    }),
    required: true
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-group"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "team-description"
  }, "Description (Optional):"), /*#__PURE__*/React.createElement("textarea", {
    id: "team-description",
    value: newTeam.description,
    onChange: e => setNewTeam({
      ...newTeam,
      description: e.target.value
    }),
    rows: "3"
  })), /*#__PURE__*/React.createElement("div", {
    className: "form-actions"
  }, /*#__PURE__*/React.createElement("button", {
    type: "submit",
    disabled: creatingTeam,
    className: "bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed"
  }, creatingTeam ? "Creating..." : "Create Team"))), /*#__PURE__*/React.createElement("div", {
    className: "teams-list"
  }, /*#__PURE__*/React.createElement("h4", null, "Existing Teams"), teams.length === 0 ? /*#__PURE__*/React.createElement("p", null, "No teams found.") : /*#__PURE__*/React.createElement("table", {
    className: "teams-table"
  }, /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("th", null, "ID"), /*#__PURE__*/React.createElement("th", null, "Name"), /*#__PURE__*/React.createElement("th", null, "Description"), /*#__PURE__*/React.createElement("th", null, "Members"), /*#__PURE__*/React.createElement("th", null, "Actions"))), /*#__PURE__*/React.createElement("tbody", null, teams.map(team => /*#__PURE__*/React.createElement("tr", {
    key: team.id
  }, /*#__PURE__*/React.createElement("td", null, team.id), /*#__PURE__*/React.createElement("td", null, editingTeam === team.id ? /*#__PURE__*/React.createElement("input", {
    type: "text",
    value: editTeamForm.name,
    onChange: e => setEditTeamForm({
      ...editTeamForm,
      name: e.target.value
    }),
    className: "edit-input"
  }) : team.name), /*#__PURE__*/React.createElement("td", null, editingTeam === team.id ? /*#__PURE__*/React.createElement("textarea", {
    value: editTeamForm.description,
    onChange: e => setEditTeamForm({
      ...editTeamForm,
      description: e.target.value
    }),
    className: "edit-input",
    rows: "2"
  }) : team.description || "No description"), /*#__PURE__*/React.createElement("td", null, team.member_count, " members"), /*#__PURE__*/React.createElement("td", null, editingTeam === team.id ? /*#__PURE__*/React.createElement("div", {
    className: "edit-actions"
  }, /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed mr-2",
    onClick: () => handleUpdateTeam(team.id),
    disabled: updatingTeam
  }, updatingTeam ? "Saving..." : "Save"), /*#__PURE__*/React.createElement("button", {
    className: "bg-neutral-500 hover:bg-neutral-600 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors disabled:bg-neutral-400 disabled:cursor-not-allowed",
    onClick: handleCancelTeamEdit,
    disabled: updatingTeam
  }, "Cancel")) : /*#__PURE__*/React.createElement("div", {
    className: "team-actions"
  }, /*#__PURE__*/React.createElement("button", {
    className: "bg-primary-600 hover:bg-primary-700 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors mr-2",
    onClick: () => handleEditTeam(team)
  }, "Edit"), /*#__PURE__*/React.createElement("button", {
    className: "bg-secondary-800 hover:bg-secondary-900 text-white px-3 py-1 rounded cursor-pointer text-sm font-medium transition-colors",
    onClick: () => handleDeleteTeam(team.id)
  }, "Delete"))))))))));
}
function App() {
  const [players, setPlayers] = useState([]);
  const [roster, setRoster] = useState([]);
  const [battles, setBattles] = useState([]);
  const [playerStats, setPlayerStats] = useState({});
  const [seasons, setSeasons] = useState([]);
  const [currentSeason, setCurrentSeason] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [currentPage, setCurrentPage] = useState("players");
  const [modal, setModal] = useState({
    isOpen: false,
    title: "",
    message: "",
    type: "info"
  });
  const showModal = (message, title = "Notification", type = "info") => {
    setModal({
      isOpen: true,
      title,
      message,
      type
    });
  };
  const closeModal = () => {
    setModal({
      isOpen: false,
      title: "",
      message: "",
      type: "info"
    });
  };
  const handlePageChange = page => {
    // Prevent non-superadmins from accessing super-admin page
    if (page === "super-admin" && !user?.is_superadmin) {
      showModal("Access denied: Super Admin privileges required", "Access Denied", "error");
      return;
    }

    // Prevent superadmins from accessing non-admin pages
    if (user?.is_superadmin && page !== "super-admin") {
      showModal("Access denied: Superusers can only access the Super Admin panel", "Access Denied", "error");
      return;
    }
    setCurrentPage(page);
  };
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState(null);
  const [authLoading, setAuthLoading] = useState(true);
  const [teams, setTeams] = useState([]);
  const [currentTeam, setCurrentTeam] = useState(null);
  const checkAuth = async () => {
    try {
      const response = await fetch("/api/auth/status");
      if (response.ok) {
        const data = await response.json();
        setIsAuthenticated(data.authenticated);
        setUser(data.user);
      } else {
        setIsAuthenticated(false);
        setUser(null);
      }
    } catch (error) {
      console.error("Error checking auth:", error);
      setIsAuthenticated(false);
      setUser(null);
    } finally {
      setAuthLoading(false);
    }
  };
  const handleLogout = async () => {
    try {
      const response = await fetch("/logout", {
        method: "POST"
      });
      if (response.ok) {
        window.location.href = "/login";
      }
    } catch (error) {
      console.error("Error logging out:", error);
    }
  };
  const fetchTeams = async () => {
    try {
      const response = await fetch("/api/auth/teams");
      if (response.ok) {
        const data = await response.json();
        setTeams(data);

        // Set current team to first if not already set
        if (!currentTeam && data.length > 0) {
          setCurrentTeam(data[0]);
        }

        // If user has no teams, set loading to false to show the "no teams" message
        if (data.length === 0) {
          setLoading(false);
        }
      } else {
        if (response.status === 401) {
          window.location.href = "/login";
          return;
        }
        setError("Failed to fetch teams");
        setLoading(false);
      }
    } catch (error) {
      setError("Network error occurred");
      setLoading(false);
    }
  };
  const fetchSeasons = async () => {
    try {
      const url = currentTeam ? `/api/seasons?team_id=${currentTeam.id}` : "/api/seasons";
      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        setSeasons(data);

        // Set current season to newest if not already set
        if (!currentSeason && data.length > 0) {
          setCurrentSeason(data[0]); // First item is newest due to desc order
        }

        // If no seasons exist, set loading to false here
        if (data.length === 0) {
          setLoading(false);
        }
      } else {
        if (response.status === 401) {
          window.location.href = "/login";
          return;
        }
        setError("Failed to fetch seasons");
        setLoading(false);
      }
    } catch (error) {
      setError("Network error occurred");
      setLoading(false);
    }
  };
  const fetchPlayers = async () => {
    try {
      if (!currentTeam) {
        setError("Please select a team first");
        return;
      }
      setError(""); // Clear any previous errors
      const url = `/api/players?status=active&team_id=${currentTeam.id}`;
      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        setPlayers(data);
      } else {
        if (response.status === 401) {
          window.location.href = "/login";
          return;
        }
        setError("Failed to fetch players");
      }
    } catch (error) {
      setError("Network error occurred");
    }
  };
  const fetchAllPlayers = async () => {
    try {
      if (!currentTeam) {
        setError("Please select a team first");
        return;
      }
      setError(""); // Clear any previous errors
      const url = `/api/players?status=all&team_id=${currentTeam.id}`;
      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        setPlayers(data);
      } else {
        if (response.status === 401) {
          window.location.href = "/login";
          return;
        }
        setError("Failed to fetch players");
      }
    } catch (error) {
      setError("Network error occurred");
    }
  };
  const fetchRoster = async () => {
    if (!currentSeason || !currentTeam) return;
    try {
      const url = `/api/players/roster?season_id=${currentSeason.id}&team_id=${currentTeam.id}`;
      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        setRoster(data);
      } else {
        if (response.status === 401) {
          window.location.href = "/login";
          return;
        }
        setError("Failed to fetch roster");
      }
    } catch (error) {
      setError("Network error occurred");
    } finally {
      setLoading(false);
    }
  };
  const fetchBattles = async () => {
    if (!currentSeason) return;
    try {
      let url = `/api/battles?season_id=${currentSeason.id}`;
      if (currentTeam) {
        url += `&team_id=${currentTeam.id}`;
      }
      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        setBattles(data);
      } else {
        setError("Failed to fetch battles");
      }
    } catch (error) {
      setError("Network error occurred");
    }
  };
  const fetchPlayerStats = async () => {
    if (!currentSeason || !currentTeam) return;
    try {
      const rosterResponse = await fetch(`/api/players/roster?season_id=${currentSeason.id}&team_id=${currentTeam.id}`);
      if (rosterResponse.ok) {
        const rosterData = await rosterResponse.json();
        const stats = {};
        await Promise.all(rosterData.map(async player => {
          const statsResponse = await fetch(`/api/players/${player.id}/battle-stats?season_id=${currentSeason.id}`);
          if (statsResponse.ok) {
            const playerStatsData = await statsResponse.json();
            stats[player.id] = playerStatsData;
          }
        }));
        setPlayerStats(stats);
      }
    } catch (error) {
      setError("Network error occurred");
    }
  };
  useEffect(() => {
    checkAuth();
  }, []);
  useEffect(() => {
    if (isAuthenticated && !authLoading) {
      fetchTeams();
    }
  }, [isAuthenticated, authLoading]);
  useEffect(() => {
    if (user) {
      if (user.is_superadmin) {
        // Superusers can only access super-admin page
        if (currentPage !== "super-admin") {
          setCurrentPage("super-admin");
        }
        // Superusers don't need team-dependent data, so set loading to false
        setLoading(false);
      } else {
        // Regular users cannot access super-admin page
        if (currentPage === "super-admin") {
          setCurrentPage("players");
        }
      }
    }
  }, [user, currentPage]);
  useEffect(() => {
    if (currentTeam) {
      fetchSeasons();
    }
  }, [currentTeam]);
  useEffect(() => {
    if (!currentTeam) return; // Don't fetch data if no team is selected

    if (currentPage === "players") {
      fetchPlayers();
      if (currentSeason) {
        fetchRoster();
        fetchPlayerStats();
      }
    } else if (currentPage === "battles") {
      if (!currentSeason) return;
      fetchBattles();
      fetchRoster();
    } else {
      fetchAllPlayers();
      if (currentSeason) {
        fetchBattles();
      }
    }
  }, [currentPage, currentSeason, currentTeam]);
  const handleTeamChange = team => {
    setCurrentTeam(team);
    setCurrentSeason(null); // Reset season when team changes
    setPlayers([]);
    setBattles([]);
    setRoster([]);
    setPlayerStats({});
    setError(""); // Clear any previous errors when team changes
  };
  const handleTeamCreated = newTeam => {
    setTeams(prev => [...prev, newTeam]);
    setCurrentTeam(newTeam);
  };
  const handlePlayerAdded = newPlayer => {
    setPlayers(prev => [...prev, newPlayer]);
  };
  const handlePlayerDeleted = playerId => {
    setPlayers(prev => prev.filter(player => player.id !== playerId));
    setRoster(prev => prev.filter(player => player.id !== playerId));
  };
  const handlePlayerStatusChanged = updatedPlayer => {
    setPlayers(prev => prev.map(player => player.id === updatedPlayer.id ? updatedPlayer : player));
    if (updatedPlayer.status === "inactive") {
      setRoster(prev => prev.filter(player => player.id !== updatedPlayer.id));
    }
  };
  const handleAddToRoster = async (playerId, position) => {
    if (!currentSeason) {
      showModal("Please select a season first", "Error", "error");
      return;
    }
    try {
      const response = await fetch(`/api/players/${playerId}/roster`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          position,
          season_id: currentSeason.id
        })
      });
      if (response.ok) {
        const updatedPlayer = await response.json();
        setRoster(prev => [...prev.filter(p => p.id !== playerId), updatedPlayer].sort((a, b) => a.roster_position - b.roster_position));
        fetchPlayerStats();
        // Refetch players to update the available players list
        fetchPlayers();
      } else {
        const errorData = await response.json();
        showModal(`Failed to add player to roster: ${errorData.error || "Unknown error"}`, "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    }
  };
  const handleRemoveFromRoster = async playerId => {
    try {
      const response = await fetch(`/api/players/${playerId}/roster`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          position: null,
          season_id: currentSeason?.id
        })
      });
      if (response.ok) {
        setRoster(prev => prev.filter(player => player.id !== playerId));
        setPlayerStats(prev => {
          const newStats = {
            ...prev
          };
          delete newStats[playerId];
          return newStats;
        });
        // Refetch players to update the available players list
        fetchPlayers();
      } else {
        const errorData = await response.json();
        showModal(`Failed to remove player from roster: ${errorData.error || "Unknown error"}`, "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    }
  };
  const handleMovePlayer = async (playerId, newPosition) => {
    try {
      const response = await fetch(`/api/players/${playerId}/roster`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          position: newPosition,
          season_id: currentSeason?.id
        })
      });
      if (response.ok) {
        fetchRoster();
      } else {
        showModal("Failed to move player", "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    }
  };
  const handleSwapPlayers = async (playerId1, playerId2) => {
    try {
      // Get the current positions of both players
      const player1 = roster.find(p => p.id === playerId1);
      const player2 = roster.find(p => p.id === playerId2);
      if (!player1 || !player2) {
        showModal("Error: Could not find players to swap", "Error", "error");
        return;
      }

      // Use the new swap endpoint
      const response = await fetch("/api/players/swap-roster", {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          player1_id: playerId1,
          player2_id: playerId2,
          season_id: currentSeason?.id
        })
      });
      if (response.ok) {
        fetchRoster();
      } else {
        const errorData = await response.json();
        showModal(`Failed to swap players: ${errorData.error || "Unknown error"}`, "Error", "error");
      }
    } catch (error) {
      showModal("Network error occurred", "Error", "error");
    }
  };
  const handleBattleAdded = newBattle => {
    setBattles(prev => [newBattle, ...prev]);
    fetchPlayerStats();
  };
  const handleBattleDeleted = battleId => {
    setBattles(prev => prev.filter(battle => battle.id !== battleId));
    fetchPlayerStats();
  };
  const handleBattleUpdated = updatedBattle => {
    setBattles(prev => prev.map(battle => battle.id === updatedBattle.id ? updatedBattle : battle));
    fetchPlayerStats();
  };
  const handleSeasonChange = season => {
    setCurrentSeason(season);
  };
  const handleSeasonCreated = newSeason => {
    setSeasons(prev => [newSeason, ...prev]);
    setCurrentSeason(newSeason);
  };
  const handleSeasonDeleted = seasonId => {
    setSeasons(prev => prev.filter(season => season.id !== seasonId));
    // If the deleted season was the current season, set current season to null
    if (currentSeason && currentSeason.id === seasonId) {
      setCurrentSeason(null);
    }
  };
  const handleSeasonUpdated = updatedSeason => {
    setSeasons(prev => prev.map(season => season.id === updatedSeason.id ? updatedSeason : season));
    // If the updated season is the current season, update it too
    if (currentSeason && currentSeason.id === updatedSeason.id) {
      setCurrentSeason(updatedSeason);
    }
  };
  if (loading) {
    return /*#__PURE__*/React.createElement("div", {
      className: "loading"
    }, "Loading...");
  }
  if (authLoading) {
    return /*#__PURE__*/React.createElement("div", {
      className: "container"
    }, /*#__PURE__*/React.createElement("div", {
      className: "loading"
    }, "Loading..."));
  }
  if (!isAuthenticated) {
    window.location.href = "/login";
    return null;
  }
  return /*#__PURE__*/React.createElement("div", {
    className: "container"
  }, /*#__PURE__*/React.createElement("div", {
    className: "header"
  }, /*#__PURE__*/React.createElement("h1", null, "Player Management System"), /*#__PURE__*/React.createElement("div", {
    className: "header-controls"
  }, !user?.is_superadmin && /*#__PURE__*/React.createElement(TeamSelector, {
    teams: teams,
    currentTeam: currentTeam,
    onTeamChange: handleTeamChange,
    onCreateTeam: handleTeamCreated,
    showCreateButton: false,
    showModal: showModal
  }), /*#__PURE__*/React.createElement("div", {
    className: "user-info"
  }, /*#__PURE__*/React.createElement("span", null, "Welcome, ", user?.username), user?.is_superadmin && /*#__PURE__*/React.createElement("span", {
    className: "superadmin-badge"
  }, "Super Admin"), /*#__PURE__*/React.createElement("button", {
    onClick: handleLogout,
    className: "bg-secondary-800 hover:bg-secondary-900 text-white px-4 py-2 rounded cursor-pointer text-sm font-medium transition-colors"
  }, "Logout")))), /*#__PURE__*/React.createElement(Navigation, {
    currentPage: currentPage,
    onPageChange: handlePageChange,
    user: user
  }), error && /*#__PURE__*/React.createElement("div", {
    className: "error"
  }, error), user?.is_superadmin ? /*#__PURE__*/React.createElement(SuperAdminPanel, {
    showModal: showModal
  }) : !currentTeam ? /*#__PURE__*/React.createElement("div", {
    className: "no-team-message"
  }, teams.length === 0 ? /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("h3", null, "No Teams Available"), /*#__PURE__*/React.createElement("p", null, "You are not currently assigned to any teams. Please contact your administrator to be assigned to a team."), /*#__PURE__*/React.createElement("p", null, "Once you have been assigned to a team, you'll be able to manage players, battles, and view statistics.")) : /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("h3", null, "Select a Team"), /*#__PURE__*/React.createElement("p", null, "Please select a team from the dropdown above to continue."))) : currentPage === "players" ? /*#__PURE__*/React.createElement("div", {
    className: "main-content"
  }, /*#__PURE__*/React.createElement("div", {
    className: "columns"
  }, /*#__PURE__*/React.createElement(PlayerList, {
    players: players,
    onPlayerDeleted: handlePlayerDeleted,
    onAddToRoster: handleAddToRoster,
    roster: roster,
    showModal: showModal
  }), /*#__PURE__*/React.createElement(ActiveRoster, {
    roster: roster,
    onRemoveFromRoster: handleRemoveFromRoster,
    onMovePlayer: handleMovePlayer,
    onSwapPlayers: handleSwapPlayers,
    playerStats: playerStats,
    seasons: seasons,
    currentSeason: currentSeason,
    onSeasonChange: handleSeasonChange,
    onCreateSeason: handleSeasonCreated,
    currentTeam: currentTeam
  }))) : currentPage === "battles" ? !currentSeason ? /*#__PURE__*/React.createElement("div", {
    className: "no-season"
  }, /*#__PURE__*/React.createElement("p", null, "Please select or create a season to manage battles."), /*#__PURE__*/React.createElement(SeasonSelector, {
    seasons: seasons,
    currentSeason: currentSeason,
    onSeasonChange: handleSeasonChange,
    onCreateSeason: handleSeasonCreated,
    currentTeam: currentTeam,
    showModal: showModal
  })) : /*#__PURE__*/React.createElement("div", {
    className: "battles-content"
  }, /*#__PURE__*/React.createElement(SeasonSelector, {
    seasons: seasons,
    currentSeason: currentSeason,
    onSeasonChange: handleSeasonChange,
    onCreateSeason: handleSeasonCreated,
    currentTeam: currentTeam,
    showModal: showModal
  }), /*#__PURE__*/React.createElement(BattleForm, {
    roster: roster,
    onBattleAdded: handleBattleAdded,
    currentSeason: currentSeason,
    currentTeam: currentTeam
  }), /*#__PURE__*/React.createElement(BattleList, {
    battles: battles,
    onBattleDeleted: handleBattleDeleted,
    onBattleUpdated: handleBattleUpdated,
    currentSeason: currentSeason,
    showModal: showModal
  })) : /*#__PURE__*/React.createElement(AdminDashboard, {
    players: players,
    onPlayerStatusChanged: handlePlayerStatusChanged,
    onPlayerDeleted: handlePlayerDeleted,
    onPlayerAdded: handlePlayerAdded,
    seasons: seasons,
    onSeasonDeleted: handleSeasonDeleted,
    onSeasonUpdated: handleSeasonUpdated,
    currentSeason: currentSeason,
    onSeasonChange: handleSeasonChange,
    onCreateSeason: handleSeasonCreated,
    battles: battles,
    onBattleUpdated: handleBattleUpdated,
    currentTeam: currentTeam
  }), /*#__PURE__*/React.createElement(Modal, {
    isOpen: modal.isOpen,
    onClose: closeModal,
    title: modal.title,
    message: modal.message,
    type: modal.type
  }));
}
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(/*#__PURE__*/React.createElement(App, null));
